(require "./myzLinear.scm")
(import myzLinear)


(use util.combinations)

(define (ls2mat ls)
  (display ls))

;(define ls (newMatrixFromList- 1 3 0 0 '(2 3 1)))
(define (ls n) (newMatrixFromList- 1 n 0 0 (upto 1 n)))

(define (vec2mat v)
  (let ((a (newMatrix (iStart v) (iEnd v) (iStart v) (iEnd v))))
    (for (upto (iStart v) (- (iEnd v) 1))
	 (lambda (i) 
	   (for (upto (+ i 1) (iEnd v))
		(lambda (j)
		  (set a (at v i (jStart v)) (at v j (jStart v)) 1)))))
    a))

(define (vecOnmat v a w)
  (for (upto (iStart v) (- (iEnd v) 1))
       (lambda (pivot) 
	 (for (upto (+ pivot 1) (iEnd v))
	      (lambda (pref)
		(let ((i (at v pivot (jStart v)))
		      (j (at v pref (jStart v))))
		  (set a i j (+ (at a i j) w))))))))


(define (allPerms n)
  (let* ((ps (permutations (upto 1 n)))
	 (allMat (newMatrix 1 n 1 (length ps)))
	 (rows (upto 1 n))
	 (cols (upto 1 (length ps))))
    (for cols
	 (lambda (j)
	   (for rows
		(lambda (i)
		  (set allMat i j (ref (ref ps (- j 1)) (- i 1)))))))
    allMat))

(define (weightedPerms n seed)
  (let* ((ps (allPerms n))
	 (ws (newMatrix 0 0 (jStart ps) (jEnd ps))))
    (makeW seed ws)
    (stdout ws)
    (stdout ps)
    (list ws ps)))

(define (makeW seed weights)
  (for (colIds weights)
       (lambda (j)
	 (set weights 0 j 
	      (+ 1 
		 (exact (floor 
                 (* (* 1 (N weights))
                    (abs (sin (* 3.14 (/ (* j seed)) (N weights)))))))))))
  )
;  (stdout weights))

(define (makeMat n seed)
  (let* ((ws (weightedPerms n seed))
	 (allPMat (cadr ws))
	 (pcm (newMatrix 1 n 1 n)))
    (for (upto (jStart allPMat) (jEnd allPMat))
	 (lambda (col)
	   (vecOnmat (nthColumn allPMat col) pcm (at (car ws) 0 col))))
    pcm))

(define (makeRSmat n seed)
  (let* ((base (makeMat n seed))
	 (rs (newMatrix (iStart base) (iEnd base) (jStart base)(jEnd base))))
    (for (upto (iStart base) (iEnd base))
	 (lambda (i)
	   (for (upto (+ i 1)(jEnd base))
		(lambda (j)
		  (set rs i j (/ (at base i j) (at base j i)))
		  (set rs j i (/ 1 (at rs i j)))))
	   (set rs i i 1)))
    (stdout rs)

    rs))

;; arth mean
(define (powerMethod2 A itrMax) 
  (if (not (equal? (colIds A) (rowIds A))) (error "power method : col idx and row idx are different."))

  (let ( (x (newMatrix (iStart A) (iEnd A) 0 0))
         )
    (map (lambda (i) 
;           (set x i (jStart x) (- (apply * (map (lambda (j) (at A i j)) (colIds A))) 0.000001)))
           (set x i (jStart x) (- (apply + (map (lambda (j) (/ (at A i j) (+ 1 (at A i j)))) (colIds A))) 0.5)))
         (rowIds A))
    (print "*********test********")
    (stdout A)
;    (normalizeColumn! x (jStart x))
    (stdout x)
    (list 0 x)))

(define (power n seed)
  (let ((pVec (cadr (powerMethod2 (makeRSmat n seed) 100))))
    (normalizeColumn! pVec (jStart pVec))
    pVec))

(define (bolda n seed)
  (let* ((ws (weightedPerms n seed))
	 (allPMat (cadr ws))
	 (w (car ws))
	 (score (newMatrix (iStart allPMat) (iEnd allPMat) 0 0)))
    (for (colIds allPMat)
	 (lambda (col)
	   (for (rowIds allPMat)
		(lambda (i)
		  (set score (at allPMat i col) 0 (+ (at score (at allPMat i col) 0) (* (at w 0 col )(+ (- n i) 0.0))))))))
    (normalizeColumn! score (jStart score))
    score))

;(define tv (newMatrixFromList- 2 5 0 0 '(2 1 1 0)))
(define (orderOfVec v)
  (let ((iorder (upto (iStart v) (iEnd v)))
	(compf (lambda (i j) (> (at v i 0) (at v j 0)))))
    (sort iorder compf car)    
  ))
(define (sameOrder u v)
  (let ((uOrder (orderOfVec u))
	(vOrder (orderOfVec v)))
    (print uOrder)
    (stdout u)
    (print vOrder)
    (stdout v)
    (print "")
    (every (lambda (x) (= (car x) (cadr x))) (map list uOrder vOrder))))    

(define (exam n maxItr)
  (if (<= maxItr 0)
      (begin (display "done")
	     maxItr)
      (begin
	(let* ((pVec (power n maxItr))
	       (bVec (bolda n maxItr)))
	  (if (not (sameOrder pVec bVec)) ;(not (= maxpi maxbi))
	      (begin (print "************* SEED ************")
;		     (print maxItr ", " n ", " maxpi ", " maxbi) ; seed
		     (print maxItr ", " n)
		     (stdout pVec)
		     (stdout bVec))
	      (exam n (- maxItr 1)))))))
